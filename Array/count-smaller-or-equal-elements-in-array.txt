STEPWISE ILLUSTRATION

 

Dry Run :

arr1 = [5,3,1] , arr2 = [3,4]

 

Apply Binary Search On Arr2 and Search Element of First Arr1 As a Target Element
 

Where 5 is target element

 

low = 0; high = 1; cnt = 0;

 

Iteration 1 :

 while(0<=1) True 

mid = (0+1)/2 = 0 

if(arr2[mid] <= target) 

cnt=mid+1 

low=mid+1 

else 

high = mid-1 

if(3<=5) True 

cnt = 0+1 = 1 

low = 0+1 = 1

 

After Iteration 1 We Got Low = 1,High = 1,Cnt = 1

 

Iteration 2 :

low = 1 high = 1 cnt = 1 

while(1<=1) True 

mid = (1+1)/2 = 1 

if(4<=5) True 

cnt = 1+1 = 2 

low = 1+1 = 2

 

After Iteration 2 We Got Low = 2,High = 1,Cnt = 2

 

Iteration 3 : low = 2 high = 1 cnt = 1 

while(2<=1) False 

Terminate Loop Then return Cnt;

 

After Iteration 3 We Got Final Ans Cnt = 2

 

Apply Same Process For arr1 to For all element  

 

CODE 

Time Complexity : O(N)+O(LogN)+O(NlogN) = O(NlogN)

Space Complexity : O(1)

 

#include <bits/stdc++.h> 
int BinarySearch(int*arr,int n,int target){
    int low = 0;
    int high = n-1;
    int cnt = 0;
    while(low <= high){
        int mid = low+(high-low)/2;
        if(arr[mid] <= target){
            cnt = mid+1;
            low = mid+1;
        }
        else{
            high = mid-1;
        }
    }
    return cnt;
}
vector < int > countSmallerOrEqual(int * a, int * b, int n, int m) {
    vector <int> ans;
    sort(b,b+m);
    for(int i=0; i<n; i++){
        int cnt = BinarySearch(b,m,a[i]);
        ans.push_back(cnt);
    }
    return ans;
}